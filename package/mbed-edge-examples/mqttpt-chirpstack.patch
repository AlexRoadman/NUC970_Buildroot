diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/base64.c _mbed-edge-examples/mqttpt-chirpstack/base64.c
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/base64.c	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/base64.c	2020-09-14 17:06:19.151427870 +0800
@@ -0,0 +1,308 @@
+/*
+ / _____)             _              | |
+( (____  _____ ____ _| |_ _____  ____| |__
+ \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ _____) ) ____| | | || |_| ____( (___| | | |
+(______/|_____)_|_|_| \__)_____)\____)_| |_|
+  (C)2013 Semtech-Cycleo
+
+Description:
+    Base64 encoding & decoding library
+
+License: Revised BSD License, see LICENSE.TXT file include in the project
+Maintainer: Sylvain Miermont
+*/
+
+
+/* -------------------------------------------------------------------------- */
+/* --- DEPENDANCIES --------------------------------------------------------- */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include "base64.h"
+
+/* -------------------------------------------------------------------------- */
+/* --- PRIVATE MACROS ------------------------------------------------------- */
+
+#define ARRAY_SIZE(a)       (sizeof(a) / sizeof((a)[0]))
+#define CRIT(a)             fprintf(stderr, "\nCRITICAL file:%s line:%u msg:%s\n", __FILE__, __LINE__,a);exit(EXIT_FAILURE)
+
+//#define DEBUG(args...)    fprintf(stderr,"debug: " args) /* diagnostic message that is destined to the user */
+#define DEBUG(args...)
+
+/* -------------------------------------------------------------------------- */
+/* --- PRIVATE CONSTANTS ---------------------------------------------------- */
+
+/* -------------------------------------------------------------------------- */
+/* --- PRIVATE MODULE-WIDE VARIABLES ---------------------------------------- */
+
+static char code_62 = '+';    /* RFC 1421 standard character for code 62 */
+static char code_63 = '/';    /* RFC 1421 standard character for code 63 */
+static char code_pad = '=';    /* RFC 1421 padding character if padding */
+
+/* -------------------------------------------------------------------------- */
+/* --- PRIVATE FUNCTIONS DECLARATION ---------------------------------------- */
+
+/**
+@brief Convert a code in the range 0-63 to an ASCII character
+*/
+char code_to_char(uint8_t x);
+
+/**
+@brief Convert an ASCII character to a code in the range 0-63
+*/
+uint8_t char_to_code(char x);
+
+/* -------------------------------------------------------------------------- */
+/* --- PRIVATE FUNCTIONS DEFINITION ----------------------------------------- */
+
+char code_to_char(uint8_t x) {
+    if (x <= 25) {
+        return 'A' + x;
+    } else if ((x >= 26) && (x <= 51)) {
+        return 'a' + (x-26);
+    } else if ((x >= 52) && (x <= 61)) {
+        return '0' + (x-52);
+    } else if (x == 62) {
+        return code_62;
+    } else if (x == 63) {
+        return code_63;
+    } else {
+        DEBUG("ERROR: %i IS OUT OF RANGE 0-63 FOR BASE64 ENCODING\n", x);
+        exit(EXIT_FAILURE);
+    } //TODO: improve error management
+}
+
+uint8_t char_to_code(char x) {
+    if ((x >= 'A') && (x <= 'Z')) {
+        return (uint8_t)x - (uint8_t)'A';
+    } else if ((x >= 'a') && (x <= 'z')) {
+        return (uint8_t)x - (uint8_t)'a' + 26;
+    } else if ((x >= '0') && (x <= '9')) {
+        return (uint8_t)x - (uint8_t)'0' + 52;
+    } else if (x == code_62) {
+        return 62;
+    } else if (x == code_63) {
+        return 63;
+    } else {
+        DEBUG("ERROR: %c (0x%x) IS INVALID CHARACTER FOR BASE64 DECODING\n", x, x);
+        exit(EXIT_FAILURE);
+    } //TODO: improve error management
+}
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC FUNCTIONS DEFINITION ------------------------------------------ */
+
+int bin_to_b64_nopad(const uint8_t * in, int size, char * out, int max_len) {
+    int i;
+    int result_len; /* size of the result */
+    int full_blocks; /* number of 3 unsigned chars / 4 characters blocks */
+    int last_bytes; /* number of unsigned chars <3 in the last block */
+    int last_chars; /* number of characters <4 in the last block */
+    uint32_t b;
+
+    /* check input values */
+    if ((out == NULL) || (in == NULL)) {
+        DEBUG("ERROR: NULL POINTER AS OUTPUT IN BIN_TO_B64\n");
+        return -1;
+    }
+    if (size == 0) {
+        *out = 0; /* null string */
+        return 0;
+    }
+
+    /* calculate the number of base64 'blocks' */
+    full_blocks = size / 3;
+    last_bytes = size % 3;
+    switch (last_bytes) {
+        case 0: /* no byte left to encode */
+            last_chars = 0;
+            break;
+        case 1: /* 1 byte left to encode -> +2 chars */
+            last_chars = 2;
+            break;
+        case 2: /* 2 bytes left to encode -> +3 chars */
+            last_chars = 3;
+            break;
+        default:
+            CRIT("switch default that should not be possible");
+    }
+
+    /* check if output buffer is big enough */
+    result_len = (4*full_blocks) + last_chars;
+    if (max_len < (result_len + 1)) { /* 1 char added for string terminator */
+        DEBUG("ERROR: OUTPUT BUFFER TOO SMALL IN BIN_TO_B64\n");
+        return -1;
+    }
+
+    /* process all the full blocks */
+    for (i=0; i < full_blocks; ++i) {
+        b  = (0xFF & in[3*i]    ) << 16;
+        b |= (0xFF & in[3*i + 1]) << 8;
+        b |=  0xFF & in[3*i + 2];
+        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);
+        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);
+        out[4*i + 2] = code_to_char((b >> 6 ) & 0x3F);
+        out[4*i + 3] = code_to_char( b        & 0x3F);
+    }
+
+    /* process the last 'partial' block and terminate string */
+    i = full_blocks;
+    if (last_chars == 0) {
+        out[4*i] =  0; /* null character to terminate string */
+    } else if (last_chars == 2) {
+        b  = (0xFF & in[3*i]    ) << 16;
+        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);
+        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);
+        out[4*i + 2] =  0; /* null character to terminate string */
+    } else if (last_chars == 3) {
+        b  = (0xFF & in[3*i]    ) << 16;
+        b |= (0xFF & in[3*i + 1]) << 8;
+        out[4*i + 0] = code_to_char((b >> 18) & 0x3F);
+        out[4*i + 1] = code_to_char((b >> 12) & 0x3F);
+        out[4*i + 2] = code_to_char((b >> 6 ) & 0x3F);
+        out[4*i + 3] = 0; /* null character to terminate string */
+    }
+
+    return result_len;
+}
+
+int b64_to_bin_nopad(const char * in, int size, uint8_t * out, int max_len) {
+    int i;
+    int result_len; /* size of the result */
+    int full_blocks; /* number of 3 unsigned chars / 4 characters blocks */
+    int last_chars; /* number of characters <4 in the last block */
+    int last_bytes; /* number of unsigned chars <3 in the last block */
+    uint32_t b;
+    ;
+
+    /* check input values */
+    if ((out == NULL) || (in == NULL)) {
+        DEBUG("ERROR: NULL POINTER AS OUTPUT OR INPUT IN B64_TO_BIN\n");
+        return -1;
+    }
+    if (size == 0) {
+        return 0;
+    }
+
+    /* calculate the number of base64 'blocks' */
+    full_blocks = size / 4;
+    last_chars = size % 4;
+    switch (last_chars) {
+        case 0: /* no char left to decode */
+            last_bytes = 0;
+            break;
+        case 1: /* only 1 char left is an error */
+            DEBUG("ERROR: ONLY ONE CHAR LEFT IN B64_TO_BIN\n");
+            return -1;
+        case 2: /* 2 chars left to decode -> +1 byte */
+            last_bytes = 1;
+            break;
+        case 3: /* 3 chars left to decode -> +2 bytes */
+            last_bytes = 2;
+            break;
+        default:
+            CRIT("switch default that should not be possible");
+    }
+
+    /* check if output buffer is big enough */
+    result_len = (3*full_blocks) + last_bytes;
+    if (max_len < result_len) {
+        DEBUG("ERROR: OUTPUT BUFFER TOO SMALL IN B64_TO_BIN\n");
+        return -1;
+    }
+
+    /* process all the full blocks */
+    for (i=0; i < full_blocks; ++i) {
+        b  = (0x3F & char_to_code(in[4*i]    )) << 18;
+        b |= (0x3F & char_to_code(in[4*i + 1])) << 12;
+        b |= (0x3F & char_to_code(in[4*i + 2])) << 6;
+        b |=  0x3F & char_to_code(in[4*i + 3]);
+        out[3*i + 0] = (b >> 16) & 0xFF;
+        out[3*i + 1] = (b >> 8 ) & 0xFF;
+        out[3*i + 2] =  b        & 0xFF;
+    }
+
+    /* process the last 'partial' block */
+    i = full_blocks;
+    if (last_bytes == 1) {
+        b  = (0x3F & char_to_code(in[4*i]    )) << 18;
+        b |= (0x3F & char_to_code(in[4*i + 1])) << 12;
+        out[3*i + 0] = (b >> 16) & 0xFF;
+        if (((b >> 12) & 0x0F) != 0) {
+            DEBUG("WARNING: last character contains unusable bits\n");
+        }
+    } else if (last_bytes == 2) {
+        b  = (0x3F & char_to_code(in[4*i]    )) << 18;
+        b |= (0x3F & char_to_code(in[4*i + 1])) << 12;
+        b |= (0x3F & char_to_code(in[4*i + 2])) << 6;
+        out[3*i + 0] = (b >> 16) & 0xFF;
+        out[3*i + 1] = (b >> 8 ) & 0xFF;
+        if (((b >> 6) & 0x03) != 0) {
+            DEBUG("WARNING: last character contains unusable bits\n");
+        }
+    }
+
+    return result_len;
+}
+
+int bin_to_b64(const uint8_t * in, int size, char * out, int max_len) {
+    int ret;
+
+    ret = bin_to_b64_nopad(in, size, out, max_len);
+
+    if (ret == -1) {
+        return -1;
+    }
+    switch (ret%4) {
+        case 0: /* nothing to do */
+            return ret;
+        case 1:
+            DEBUG("ERROR: INVALID UNPADDED BASE64 STRING\n");
+            return -1;
+        case 2: /* 2 chars in last block, must add 2 padding char */
+            if (max_len >= (ret + 2 + 1)) {
+                out[ret] = code_pad;
+                out[ret+1] = code_pad;
+                out[ret+2] = 0;
+                return ret+2;
+            } else {
+                DEBUG("ERROR: not enough room to add padding in bin_to_b64\n");
+                return -1;
+            }
+        case 3: /* 3 chars in last block, must add 1 padding char */
+            if (max_len >= (ret + 1 + 1)) {
+                out[ret] = code_pad;
+                out[ret+1] = 0;
+                return ret+1;
+            } else {
+                DEBUG("ERROR: not enough room to add padding in bin_to_b64\n");
+                return -1;
+            }
+        default:
+            CRIT("switch default that should not be possible");
+    }
+}
+
+int b64_to_bin(const char * in, int size, uint8_t * out, int max_len) {
+    if (in == NULL) {
+        DEBUG("ERROR: NULL POINTER AS OUTPUT OR INPUT IN B64_TO_BIN\n");
+        return -1;
+    }
+    if ((size%4 == 0) && (size >= 4)) { /* potentially padded Base64 */
+        if (in[size-2] == code_pad) { /* 2 padding char to ignore */
+            return b64_to_bin_nopad(in, size-2, out, max_len);
+        } else if (in[size-1] == code_pad) { /* 1 padding char to ignore */
+            return b64_to_bin_nopad(in, size-1, out, max_len);
+        } else { /* no padding to ignore */
+            return b64_to_bin_nopad(in, size, out, max_len);
+        }
+    } else { /* treat as unpadded Base64 */
+        return b64_to_bin_nopad(in, size, out, max_len);
+    }
+}
+
+
+/* --- EOF ------------------------------------------------------------------ */
diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/base64.h _mbed-edge-examples/mqttpt-chirpstack/base64.h
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/base64.h	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/base64.h	2020-09-14 17:06:19.151427870 +0800
@@ -0,0 +1,62 @@
+/*
+ / _____)             _              | |
+( (____  _____ ____ _| |_ _____  ____| |__
+ \____ \| ___ |    (_   _) ___ |/ ___)  _ \
+ _____) ) ____| | | || |_| ____( (___| | | |
+(______/|_____)_|_|_| \__)_____)\____)_| |_|
+  (C)2013 Semtech-Cycleo
+
+Description:
+    Base64 encoding & decoding library
+
+License: Revised BSD License, see LICENSE.TXT file include in the project
+Maintainer: Sylvain Miermont
+*/
+
+
+#ifndef _BASE64_H
+#define _BASE64_H
+
+/* -------------------------------------------------------------------------- */
+/* --- DEPENDANCIES --------------------------------------------------------- */
+
+#include <stdint.h>        /* C99 types */
+
+/* -------------------------------------------------------------------------- */
+/* --- PUBLIC FUNCTIONS PROTOTYPES ------------------------------------------ */
+
+/**
+@brief Encode binary data in Base64 string (no padding)
+@param in pointer to a table of binary data
+@param size number of bytes to be encoded to base64
+@param out pointer to a string where the function will output encoded data
+@param max_len max length of the out string (including null char)
+@return >=0 length of the resulting string (w/o null char), -1 for error
+*/
+int bin_to_b64_nopad(const uint8_t * in, int size, char * out, int max_len);
+
+/**
+@brief Decode Base64 string to binary data (no padding)
+@param in string containing only base64 valid characters
+@param size number of characters to be decoded from base64 (w/o null char)
+@param out pointer to a data buffer where the function will output decoded data
+@param out_max_len usable size of the output data buffer
+@return >=0 number of bytes written to the data buffer, -1 for error
+*/
+int b64_to_bin_nopad(const char * in, int size, uint8_t * out, int max_len);
+
+/* === derivative functions === */
+
+/**
+@brief Encode binary data in Base64 string (with added padding)
+*/
+int bin_to_b64(const uint8_t * in, int size, char * out, int max_len);
+
+/**
+@brief Decode Base64 string to binary data (remove padding if necessary)
+*/
+int b64_to_bin(const char * in, int size, uint8_t * out, int max_len);
+
+#endif
+
+/* --- EOF ------------------------------------------------------------------ */
diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/CMakeLists.txt _mbed-edge-examples/mqttpt-chirpstack/CMakeLists.txt
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/CMakeLists.txt	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/CMakeLists.txt	2020-09-14 16:40:56.536108259 +0800
@@ -0,0 +1,13 @@
+file (GLOB SOURCES ./*.c ../lib/${EDGE_SOURCES_DIR_NAME}/common/edge_trace.c)
+
+include_directories (${CMAKE_CURRENT_LIST_DIR}/include)
+
+add_executable (mqttpt-chirpstack ${SOURCES})
+
+add_definitions(-DMBED_CONF_MBED_TRACE_ENABLE=1)
+
+target_include_directories (mqttpt-chirpstack PUBLIC ${CMAKE_CURRENT_LIST_DIR} ${PROJECT_BINARY_DIR}/lib/${EDGE_SOURCES_DIR_NAME}/lib/jansson/include)
+target_include_directories (mqttpt-chirpstack PUBLIC ${ROOT_HOME}/include)
+
+target_link_libraries (mqttpt-chirpstack pthread examples-common-2 pt-client-2 mosquitto)
+
diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack.c _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack.c
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack.c	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack.c	2020-09-14 17:57:02.934130685 +0800
@@ -0,0 +1,1004 @@
+/*
+ * ----------------------------------------------------------------------------
+ * Copyright 2018 ARM Ltd.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ----------------------------------------------------------------------------
+ */
+
+#include <signal.h>
+#include <errno.h>
+
+#include "mosquitto.h"
+#include "ns_list.h"
+#include "common/constants.h"
+#include "pt-client-2/pt_api.h"
+#include "pt-client-2/pt_certificate_api.h"
+#include "pt-client-2/pt_crypto_api.h"
+#include "mbed-trace/mbed_trace.h"
+#include "examples-common-2/client_config.h"
+#include "mqttpt_chirpstack_clip.h"
+#include "common/edge_trace.h"
+#include "common/apr_base64.h"
+
+#define TRACE_GROUP "mqtt-example"
+
+#include "jansson.h"
+
+#include <pthread.h>
+#include <semaphore.h>
+#include <unistd.h>
+
+connection_id_t g_connection_id = PT_API_CONNECTION_ID_INVALID;
+pt_api_mutex_t *g_devices_mutex = NULL;
+sem_t mosquitto_stop;
+struct mosquitto *mosq = NULL;
+char* g_app_id = NULL;
+
+void mqttpt_connection_ready_handler(connection_id_t connection_id, const char *name, void *ctx);
+bool setup_signals(void);
+
+void mqttpt_protocol_translator_registration_success_handler(void *ctx);
+void mqttpt_protocol_translator_registration_failure_handler(void *ctx);
+
+void mqttpt_shutdown_handler(connection_id_t connection_id, void *ctx);
+sem_t mqttpt_translator_started;
+pthread_t mqttpt_thread;
+#define MQTTPT_DEFAULT_LIFETIME 10000
+
+typedef enum
+{
+    SENSOR_TEMPERATURE,
+    SENSOR_HUMIDITY
+} sensor_type_e;
+
+/*
+ * Bookkeeping to keep track of devices registered or "seen"
+ */
+
+typedef struct
+{
+    ns_list_link_t link;
+    const char *deveui;
+} mqttpt_device_t;
+
+typedef struct
+{
+    char *request_id;
+    char *certificate;
+} pt_api_request_userdata_t;
+
+/**
+ * \brief Structure to pass the protocol translator initialization
+ * data to the protocol translator API.
+ */
+typedef struct protocol_translator_api_start_ctx
+{
+    const char *socket_path;
+    pt_client_t *client;
+} protocol_translator_api_start_ctx_t;
+
+protocol_translator_api_start_ctx_t *global_pt_ctx;
+
+typedef NS_LIST_HEAD(mqttpt_device_t, link) mqttpt_device_list_t;
+bool protocol_translator_shutdown_handler_called = false;
+mqttpt_device_list_t *mqttpt_devices;
+void mqttpt_add_device(const char *deveui)
+{
+    if (deveui == NULL)
+    {
+        return;
+    }
+    mqttpt_device_t *device = (mqttpt_device_t *) calloc(1, sizeof(mqttpt_device_t));
+    if (device == NULL)
+    {
+        return;
+    }
+    device->deveui = strdup(deveui);
+    tr_info("Adding device to list");
+    ns_list_add_to_end(mqttpt_devices, device);
+}
+
+int mqttpt_device_exists(const char *deveui)
+{
+    tr_info("Checking device '%s' exists", deveui);
+    ns_list_foreach(mqttpt_device_t, device, mqttpt_devices)
+    {
+        tr_info("Checking %s", device->deveui);
+        if (strcmp(deveui, device->deveui) == 0)
+        {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+pt_api_request_userdata_t *create_pt_api_request_userdata(const char *request_id)
+{
+    pt_api_request_userdata_t *userdata = calloc(1, sizeof(pt_api_request_userdata_t));
+    char *request_id_copy = strdup(request_id);
+    if (userdata == NULL || request_id_copy == NULL)
+    {
+        free(userdata);
+        free(request_id_copy);
+        return NULL;
+    }
+
+    userdata->request_id = request_id_copy;
+    return userdata;
+}
+
+/*
+ * Protocol translator's internal eventloop needs a thread to run in
+ */
+void *mqttpt_translator_thread_routine(void *ctx)
+{
+    const protocol_translator_api_start_ctx_t *pt_start_ctx = (protocol_translator_api_start_ctx_t *) global_pt_ctx;
+    pt_client_start(pt_start_ctx->client,
+                    mqttpt_protocol_translator_registration_success_handler,
+                    mqttpt_protocol_translator_registration_failure_handler,
+                    "testing-mqtt",
+                    ctx);
+    return NULL;
+}
+
+void mqttpt_start_translator(struct mosquitto *mosq)
+{
+    int started;
+    sem_getvalue(&mqttpt_translator_started, &started);
+    if (started == 0)
+    {
+        pthread_create(&mqttpt_thread, NULL, &mqttpt_translator_thread_routine, (void *) mosq);
+        sem_post(&mqttpt_translator_started);
+    }
+}
+
+static void publish_to_mqtt(const char *topic, json_t *json_message)
+{
+    char *result_string = json_dumps(json_message, JSON_COMPACT);
+    if (result_string == NULL)
+    {
+        tr_err("Could not create mqtt message string.");
+        return;
+    }
+    tr_info("Publishing result: %s", result_string);
+    mosquitto_publish(mosq, NULL, topic, strlen(result_string), result_string, 0, 0);
+    free(result_string);
+}
+
+/* Certificate renewal notification message format:
+ * {
+ * "certificate": "certificate the the notification affects",
+ * "message": "message informing the status of the renewal, can be either success or failure"
+ * }
+ */
+static void construct_and_send_certificate_renewal_notification(const char *certificate, const char *message)
+{
+    json_t *result_json = json_object();
+    if (result_json == NULL)
+    {
+        tr_err("Could not allocate JSON for certificate renewal notification message. (cert: %s)", certificate);
+        return;
+    }
+    json_object_set_new(result_json, "certificate", json_string(certificate));
+    json_object_set_new(result_json, "message", json_string(message));
+
+    publish_to_mqtt("MQTTPt/CertificateRenewal", result_json);
+
+    json_decref(result_json);
+}
+
+/* Certificate renewal notification message format:
+ * {
+ * "message": "message informing the status of the registration of the protocol translator"
+ * "device": "if message applies to specific device, this field is present and contains the device identifier"
+ * }
+ */
+static void construct_and_send_device_notification(const char *message, const char *dev_ui)
+{
+    json_t *result_json = json_object();
+    if (result_json == NULL)
+    {
+        tr_err("Could not allocate JSON for translator registration notification message.");
+        return;
+    }
+
+    json_object_set_new(result_json, "message", json_string(message));
+    if (dev_ui)
+    {
+        json_object_set_new(result_json, "device", json_string(dev_ui));
+    }
+
+    publish_to_mqtt("MQTTPt/DeviceRegistration", result_json);
+
+    json_decref(result_json);
+}
+
+/* Certificate renewal notification message format:
+ * {
+ * "message": "message informing the status of the registration of the protocol translator"
+ * }
+ */
+static void construct_and_send_translator_registration_notification(const char *message)
+{
+    json_t *result_json = json_object();
+    if (result_json == NULL)
+    {
+        tr_err("Could not allocate JSON for translator registration notification message.");
+        return;
+    }
+
+    json_object_set_new(result_json, "message", json_string(message));
+
+    publish_to_mqtt("MQTTPt/TranslatorRegistration", result_json);
+
+    json_decref(result_json);
+}
+
+/* Device certificate renewal request message format:
+ * {
+ * "device": "Id of device whose certificate should be renewed",
+ * "certificate_name": "Name of the certificate that was enrolled"
+ * }
+ */
+static void construct_and_send_device_certificate_renewal_request(const char *device_name, const char *cert_name)
+{
+    json_t *result_json = json_object();
+    if (result_json == NULL)
+    {
+        tr_err("Could not allocate JSON for certificate renewal request message. (device: %s, cert: %s)", device_name, cert_name);
+        return;
+    }
+    json_object_set_new(result_json, "device", json_string(device_name));
+    json_object_set_new(result_json, "certificate_name", json_string(cert_name));
+
+    publish_to_mqtt("MQTTPt/DeviceCertificateRenewalRequest", result_json);
+    json_decref(result_json);
+}
+
+/*
+ * Callback handlers for PT operations
+ */
+
+void mqttpt_device_register_success_handler(const connection_id_t connection_id, const char *device_id, void *ctx)
+{
+    if (ctx)
+    {
+        tr_info("A device register finished successfully.");
+        tr_info("deveui %s", (char *)ctx);
+        construct_and_send_device_notification("successful_registration", (const char *)ctx);
+        mqttpt_add_device((const char *)ctx);
+    }
+    free(ctx);
+}
+
+void mqttpt_device_register_failure_handler(const connection_id_t connection_id, const char *device_id, void *ctx)
+{
+    tr_info("A device register failed.");
+    construct_and_send_device_notification("failed_registration", (const char *)ctx);
+    free(ctx);
+}
+
+void mqttpt_devices_unregister_success_handler(connection_id_t connection_id, void *userdata)
+{
+    tr_info("Devices unregistration success.");
+    (void) connection_id;
+    (void) userdata;
+    construct_and_send_device_notification("successful_unregistration", NULL);
+    pt_client_shutdown(global_pt_ctx->client);
+}
+
+void mqttpt_devices_unregister_failure_handler(connection_id_t connection_id, void *userdata)
+{
+    tr_err("Devices unregistration failed.");
+    (void) connection_id;
+    (void) userdata;
+    construct_and_send_device_notification("failed_unregistration", NULL);
+    pt_client_shutdown(global_pt_ctx->client);
+}
+
+void mqttpt_update_object_structure_success_handler(connection_id_t connection_id, const char *device_id, void *ctx)
+{
+    (void) connection_id;
+    tr_info("Object structure update finished successfully.");
+    free(ctx);
+}
+
+void mqttpt_update_object_structure_failure_handler(connection_id_t connection_id, const char *device_id, void *ctx)
+{
+    (void) connection_id;
+    tr_info("Object structure update failed.");
+    free(ctx);
+}
+
+void mqttpt_protocol_translator_registration_success_handler(void *ctx)
+{
+    (void) ctx;
+    sem_post(&mqttpt_translator_started);
+    tr_info("MQTT translator registered successfully.");
+    construct_and_send_translator_registration_notification("successful_registration");
+}
+
+void mqttpt_protocol_translator_registration_failure_handler(void *ctx)
+{
+    (void) ctx;
+    tr_info("MQTT translator registration failed.");
+    sem_post(&mosquitto_stop);
+    construct_and_send_translator_registration_notification("failed_registration");
+}
+
+pt_status_t mqtt_minmax_reset_callback(const connection_id_t connection_id,
+                                       const char *device_id,
+                                       const uint16_t object_id,
+                                       const uint16_t instance_id,
+                                       const uint16_t resource_id,
+                                       const uint8_t operation,
+                                       const uint8_t *value,
+                                       const uint32_t value_size,
+                                       void *userdata)
+{
+    tr_info("Min / Max resource reset callback for (%s/%d/%d/%d)",
+            device_id,
+            object_id,
+            instance_id,
+            resource_id);
+    return PT_STATUS_SUCCESS;
+}
+
+pt_status_t mqtt_write_callback(const connection_id_t connection_id,
+                                const char *device_id,
+                                const uint16_t object_id,
+                                const uint16_t instance_id,
+                                const uint16_t resource_id,
+                                const uint8_t operation,
+                                const uint8_t *value,
+                                const uint32_t value_size,
+                                void *userdata)
+{
+    int i = 0;
+    char topic[128];
+
+    printf("Write resource for (%s/%d/%d/%d/%d)\n",
+           device_id,
+           object_id,
+           instance_id,
+           resource_id,
+           operation);
+
+    printf("Value: ");
+    for (i = 0; i < value_size; i++)
+        printf("%x ", value[i]);
+    printf("\n");
+
+    //application/<app-id>/device/<device-eui>/command/down
+
+    /*
+    {
+      "confirmed": true,
+      "fPort": 1,
+      "data": "AQID"
+    }
+    */
+    snprintf(topic, sizeof(topic), "application/%s/device/%s/command/down", g_app_id, device_id);
+
+    char *encoded_msg = calloc(1, sizeof(char) * apr_base64_encode_len(value_size));
+    if (encoded_msg == NULL)
+    {
+        tr_err("Could not allocate char pointer for returning the item.");
+        return PT_STATUS_ERROR;
+    }
+    apr_base64_encode_binary(encoded_msg, (const unsigned char *)value, value_size);
+
+    json_t *result_json = json_object();
+    if (result_json == NULL)
+    {
+        tr_err("Could not allocate JSON for MQTT downlink message.");
+        return PT_STATUS_ERROR;
+    }
+    json_object_set_new(result_json, "confirmed", json_true());
+    json_object_set_new(result_json, "fPort", json_integer(1));
+    json_object_set_new(result_json, "data", json_string(encoded_msg));
+    publish_to_mqtt(topic, result_json);
+    json_decref(result_json);
+    free(encoded_msg);
+    return PT_STATUS_SUCCESS;
+}
+
+pt_status_t mqtt_example_callback(const connection_id_t connection_id,
+                                  const char *device_id,
+                                  const uint16_t object_id,
+                                  const uint16_t instance_id,
+                                  const uint16_t resource_id,
+                                  const uint8_t operation,
+                                  const uint8_t *value,
+                                  const uint32_t value_size,
+                                  void *userdata)
+{
+    tr_debug("Example callback for (%s/%d/%d/%d)",
+           device_id,
+           object_id,
+           instance_id,
+           resource_id);
+    return PT_STATUS_SUCCESS;
+}
+
+void mqttpt_connection_ready_handler(connection_id_t connection_id, const char *name, void *ctx)
+{
+    tr_info("mqttpt_connection_ready_handler for connection with id %d name '%s'", connection_id, name);
+    g_connection_id = connection_id;
+}
+
+void mqttpt_shutdown_handler(connection_id_t connection_id, void *userdata)
+{
+    (void) connection_id;
+    (void) userdata;
+    tr_info("Shutting down the mqttpt example");
+}
+
+void mqttpt_disconnected_handler(connection_id_t connection_id, void *userdata)
+{
+    (void) connection_id;
+    tr_info("Protocol translator disconnected from the Edge Core.");
+}
+
+void mqtt_certificate_renewal_notification_handler(const connection_id_t connection_id,
+        const char *name,
+        int32_t initiator,
+        int32_t status,
+        const char *description,
+        void *userdata)
+{
+    (void) connection_id;
+    tr_info("Certificate renewal notification from the Edge Core: name: '%s' initiator: %d status: %d description: "
+            "'%s'",
+            name,
+            initiator,
+            status,
+            description);
+    construct_and_send_certificate_renewal_notification(name, description);
+}
+
+pt_status_t mqtt_device_certificate_renewal_request_handler(const connection_id_t connection_id,
+        const char *device_id,
+        const char *name,
+        void *userdata)
+{
+    tr_info("Certificate renewal request for device: %s, certificate: %s", device_id, name);
+    construct_and_send_device_certificate_renewal_request(device_id, name);
+    return PT_STATUS_SUCCESS;
+}
+
+/*
+ * Create the lwm2m structure for a "generic" sensor object. Same resources can be used
+ * to represent temperature and humidity sensors by just changing the object id
+ * temperature sensor id = 3303 (http://www.openmobilealliance.org/tech/profiles/lwm2m/3303.xml)
+ * humidity sensor id = 3304 (http://www.openmobilealliance.org/tech/profiles/lwm2m/3304.xml)
+ */
+bool mqttpt_create_sensor_object(connection_id_t connection_id, const char *deveui, int object_id, int object_instance, const char *value)
+{
+
+    if (value == NULL || deveui == NULL)
+    {
+        return false;
+    }
+
+    // Resource value buffer ownership is transferred so we need to make copies of the const buffers passed in
+    char *value_buf = strdup(value);
+
+    if (value_buf == NULL)
+    {
+        free(value_buf);
+        return false;
+    }
+
+    pt_status_t status = pt_device_add_resource(connection_id,
+                         deveui,
+                         object_id,
+                         object_instance,
+                         5700,
+                         LWM2M_OPAQUE,
+                         (uint8_t *) value_buf,
+                         strlen(value_buf),
+                         free);
+    status = pt_device_add_resource_with_callback(connection_id,
+             deveui,
+             object_id,
+             object_instance,
+             5605,
+             LWM2M_OPAQUE,
+             OPERATION_EXECUTE,
+             NULL,
+             0,
+             free,
+             mqtt_minmax_reset_callback);
+    if (status != PT_STATUS_SUCCESS)
+    {
+        tr_err("Resource creation failed, status %d\n", status);
+        return false;
+    }
+
+    return true;
+}
+
+/* Create a structure using the given LWM2M object identifiers and default callbacks */
+bool mqttpt_create_object(connection_id_t connection_id, const char *deveui, int object_id, int object_instance, int resource_id, const char *value, int operations)
+{
+    if (value == NULL || deveui == NULL)
+    {
+        return false;
+    }
+
+    // Resource value buffer ownership is transferred so we need to make copies of the const buffers passed in
+    char *value_buf = strdup(value);
+
+    if (value_buf == NULL)
+    {
+        free(value_buf);
+        return false;
+    }
+    printf("operations=%d\n", operations);
+    pt_status_t status = PT_STATUS_ERROR;
+    //Read Only resource
+    if (operations == 1)
+    {
+        status = pt_device_add_resource(connection_id,
+                                        deveui,
+                                        object_id,
+                                        object_instance,
+                                        resource_id,
+                                        LWM2M_OPAQUE,
+                                        (uint8_t *) value_buf,
+                                        strlen(value_buf),
+                                        free);
+    }
+    //Read / Write resource
+    else if (operations == 3)
+    {
+        status = pt_device_add_resource_with_callback(connection_id,
+                 deveui,
+                 object_id,
+                 object_instance,
+                 resource_id,
+                 LWM2M_OPAQUE,
+                 OPERATION_READ | OPERATION_WRITE,
+                 (uint8_t *) value_buf,
+                 strlen(value_buf),
+                 free,
+                 mqtt_write_callback);
+    }
+    else
+    {
+        status = pt_device_add_resource_with_callback(connection_id,
+                 deveui,
+                 object_id,
+                 object_instance,
+                 resource_id,
+                 LWM2M_OPAQUE,
+                 operations,
+                 (uint8_t *) value_buf,
+                 strlen(value_buf),
+                 free,
+                 mqtt_example_callback);
+    }
+
+    if (status != PT_STATUS_SUCCESS)
+    {
+        tr_err("Resource creation failed, status %d\n", status);
+        return false;
+    }
+
+    return true;
+}
+
+void mqttpt_translate_node_edge_value_message(struct mosquitto *mosq,
+        const char *gweui,
+        char *deveui,
+        const char *payload,
+        const int payload_len)
+{
+    json_error_t error;
+    int object_id = 3300;
+    int object_instance = 0;
+    int resource_id = 5700;
+    int resource_operations = 3;
+    char *value_bin = NULL;
+    int value_bin_len = 0;
+
+    tr_info("Translating edge value message");
+
+    int started;
+    sem_getvalue(&mqttpt_translator_started, &started);
+    if (started == 0)
+    {
+        mqttpt_start_translator(mosq);
+        tr_info("Translating edge value message, PT was not registered yet registering it now.");
+        return;
+    }
+
+    if (gweui == NULL || deveui == NULL || payload == NULL)
+    {
+        tr_err("Translating edge value message, missing gweui, deveui or payload.");
+        return;
+    }
+
+    json_t *json = json_loads(payload, 0, &error);
+    if (json == NULL)
+    {
+        tr_err("Translating edge value message, could not parse json.");
+        return;
+    }
+
+    json_t *object = json_object_get(json, "data");
+    if (object == NULL)
+    {
+        tr_err("Translating edge value message, json missing object.");
+        json_decref(json);
+        return;
+    }
+    const char *value = json_string_value(object);
+    value_bin_len = strlen(value);
+    value_bin = (char *) malloc(sizeof(char) * value_bin_len);
+    if (!value_bin)
+    {
+        tr_err("malloc failure.");
+        json_decref(json);
+        return;
+    }
+
+    if ((value_bin_len = b64_to_bin(value, value_bin_len, (uint8_t *)value_bin, value_bin_len)) < 0)
+    {
+        tr_err("b64_to_bin failure.");
+        json_decref(json);
+        free(value_bin);
+        return;
+    }
+
+    printf("appid: %s, deveui: %s, data: %s, value=%s\n", gweui, deveui, value, value_bin);
+
+    bool cert_renewal_support = false;
+    json_t *cert_renewal_field = json_object_get(json, "cert_renewal");
+    if (cert_renewal_field && json_boolean_value(cert_renewal_field))
+    {
+        cert_renewal_support = true;
+    }
+
+    // We store lwm2m representation of node values into pt_object_list_t
+    // Create the device structure if device does not exist yet.
+    if (!pt_device_exists(g_connection_id, deveui))
+    {
+        uint32_t features = PT_DEVICE_FEATURE_NONE;
+        if (cert_renewal_support)
+        {
+            features |= PT_DEVICE_FEATURE_CERTIFICATE_RENEWAL;
+        }
+        pt_status_t status = pt_device_create_with_feature_flags(g_connection_id, deveui, MQTTPT_DEFAULT_LIFETIME, NONE, features, NULL);
+        if (status != PT_STATUS_SUCCESS)
+        {
+            tr_err("Could not create a device %s error code: %d", deveui, (int32_t) status);
+            return;
+        }
+    }
+
+    if (!pt_device_resource_exists(g_connection_id, deveui, object_id, object_instance, resource_id))
+    {
+        printf("Creating generic object.");
+        mqttpt_create_object(g_connection_id, deveui, object_id, object_instance, resource_id, value, resource_operations);
+    }
+
+    pt_device_set_resource_value(g_connection_id,
+                                 deveui,
+                                 object_id,
+                                 object_instance,
+                                 resource_id,
+                                 (uint8_t *)value_bin,
+                                 value_bin_len,
+                                 free);
+
+
+    char *deveui_ctx = strdup(deveui);
+    // If device has been registered, then just write the new values
+    if (mqttpt_device_exists(deveui))
+    {
+        tr_info("Updating the changed object structure %s\n", deveui_ctx);
+        pt_device_write_values(g_connection_id,
+                               deveui,
+                               mqttpt_update_object_structure_success_handler,
+                               mqttpt_update_object_structure_failure_handler,
+                               deveui_ctx);
+    }
+    else
+    {
+        // If device has not been registered yet, register it
+        tr_info("Registering device %s\n", deveui_ctx);
+        pt_device_register(g_connection_id,
+                           deveui,
+                           mqttpt_device_register_success_handler,
+                           mqttpt_device_register_failure_handler,
+                           deveui_ctx);
+    }
+
+    json_decref(json);
+}
+
+/*
+ * Function for parsing the mqtt messages we receive from the MQTT gateway.
+ * The event type is parsed from topic field and id's and values are parsed from payload.
+ *
+ * Node values: application/{app-id}/device/xxxxxxx-xxxxxxx/event/{event}
+ */
+#define MQTT_TOPIC_OFFSET_COUNT 6
+void mqttpt_handle_message(struct mosquitto *mosq, char *topic, char *payload, int payload_len)
+{
+    char *saveptr;
+    // Parse topic offsets to identify event and id's
+    char *topic_offset[MQTT_TOPIC_OFFSET_COUNT];
+
+    if (topic == NULL)
+    {
+        return;
+    }
+
+    topic_offset[0] = strtok_r(topic, "/", &saveptr);; // points to "application"
+    topic_offset[1] = strtok_r(NULL, "/", &saveptr); // points to "{application_id}"
+    topic_offset[2] = strtok_r(NULL, "/", &saveptr); // points to "device"
+    topic_offset[3] = strtok_r(NULL, "/", &saveptr); // points to "{deveui}"
+    topic_offset[4] = strtok_r(NULL, "/", &saveptr); // points to "event"
+    topic_offset[5] = strtok_r(NULL, "/", &saveptr); // points to "{event}"
+
+    tr_info("mqttpt handling message");
+    tr_info("topic 0: %s", topic_offset[0]);
+    tr_info("topic 1: %s", topic_offset[1]);
+    tr_info("topic 2: %s", topic_offset[2]);
+    tr_info("topic 3: %s", topic_offset[3]);
+    tr_info("topic 4: %s", topic_offset[4]);
+    tr_info("topic 5: %s", topic_offset[5]);
+
+    if (strcmp(topic_offset[0], "application") == 0)
+    {
+        if (topic_offset[2] == NULL)
+        {
+            // Topic missing Evt or Node
+            tr_err("application message missing Evt or Node part.");
+            return;
+        }
+
+        if (strncmp(g_app_id, topic_offset[1], strlen(g_app_id)) != 0)
+        {
+                tr_err("application id is not matched.");
+                return;
+        }
+
+        if ((strcmp(topic_offset[2], "device") == 0) && (strcmp(topic_offset[4], "event") == 0))
+        {
+            if (topic_offset[3] == NULL || topic_offset[5] == NULL)
+            {
+                tr_err("application message missing deveui or event type.");
+                return;
+            }
+
+            if (strcmp(topic_offset[5], "up") == 0)
+            {
+                mqttpt_translate_node_edge_value_message(mosq, topic_offset[1], topic_offset[3], payload, payload_len);
+            }
+        }
+        else
+        {
+            ;
+        }
+    }
+    else
+    {
+        tr_err("Unknown topic in message");
+    }
+}
+
+void mqtt_message_callback(struct mosquitto *mosq, void *userdata, const struct mosquitto_message *message)
+{
+    if (protocol_translator_shutdown_handler_called)
+    {
+        tr_info("mqtt_message_callback: shutting down mosquitto loop.");
+    }
+    if (message->payloadlen)
+    {
+        tr_info("%s %s", message->topic, (char *) message->payload);
+        mqttpt_handle_message(mosq, message->topic, message->payload, message->payloadlen);
+    }
+    else
+    {
+        tr_info("%s (null)", message->topic);
+    }
+    fflush(stdout);
+}
+
+void mqtt_connect_callback(struct mosquitto *mosq, void *userdata, int result)
+{
+    if (!result)
+    {
+        mosquitto_subscribe(mosq, NULL, "application/#", 2);
+    }
+    else
+    {
+        tr_err("Connect failed");
+    }
+}
+
+void mqtt_subscribe_callback(struct mosquitto *mosq, void *userdata, int mid, int qos_count, const int *granted_qos)
+{
+    int i;
+
+    printf("Subscribed (mid: %d): %d", mid, granted_qos[0]);
+    for (i = 1; i < qos_count; i++)
+    {
+        printf(", %d", granted_qos[i]);
+    }
+    printf("\n");
+}
+
+void mqtt_log_callback(struct mosquitto *mosq, void *userdata, int level, const char *str)
+{
+    /* Pring all log messages regardless of level. */
+    tr_info("%s", str);
+}
+
+static void shutdown_and_cleanup()
+{
+    int started;
+    sem_getvalue(&mqttpt_translator_started, &started);
+    if (started)
+    {
+        pt_status_t status = pt_devices_unregister_devices(g_connection_id,
+                             mqttpt_devices_unregister_success_handler,
+                             mqttpt_devices_unregister_failure_handler,
+                             NULL);
+        if (status != PT_STATUS_SUCCESS)
+        {
+            tr_warn("Device unregistration failed.");
+            pt_client_shutdown(global_pt_ctx->client);
+        }
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    bool clean_session = true;
+    mosq = NULL;
+
+    setup_signals();
+
+    DocoptArgs args = docopt(argc, argv, /* help */ 1, /* version */ "0.1");
+    edge_trace_init(args.color_log);
+    mqttpt_devices = (mqttpt_device_list_t *) calloc(1, sizeof(mqttpt_device_list_t));
+    ns_list_init(mqttpt_devices);
+    pt_api_init();
+    protocol_translator_callbacks_t *pt_cbs = calloc(1, sizeof(protocol_translator_callbacks_t));
+    pt_cbs->connection_ready_cb = mqttpt_connection_ready_handler;
+    pt_cbs->connection_shutdown_cb = mqttpt_shutdown_handler;
+    pt_cbs->disconnected_cb = mqttpt_disconnected_handler;
+    pt_cbs->certificate_renewal_notifier_cb = mqtt_certificate_renewal_notification_handler;
+    pt_cbs->device_certificate_renew_request_cb = mqtt_device_certificate_renewal_request_handler;
+
+    global_pt_ctx = malloc(sizeof(protocol_translator_api_start_ctx_t));
+
+    global_pt_ctx->socket_path = args.edge_domain_socket;
+    pt_client_t *client = pt_client_create(global_pt_ctx->socket_path,
+                                           pt_cbs);
+    global_pt_ctx->client = client;
+
+    mosquitto_lib_init();
+    mosq = mosquitto_new(NULL, clean_session, NULL);
+    if (!mosq)
+    {
+        tr_err("Error: Out of memory.");
+        return 1;
+    }
+
+    mosquitto_log_callback_set(mosq, mqtt_log_callback);
+    mosquitto_connect_callback_set(mosq, mqtt_connect_callback);
+    mosquitto_message_callback_set(mosq, mqtt_message_callback);
+    mosquitto_subscribe_callback_set(mosq, mqtt_subscribe_callback);
+
+    if (mosquitto_connect(mosq, args.mosquitto_host,
+                          atoi(args.mosquitto_port),
+                          atoi(args.keep_alive)))
+    {
+        tr_err("Unable to connect.");
+        return 1;
+    }
+
+    g_app_id = args.app_id;
+
+    sem_init(&mosquitto_stop, 0, 0);
+    int stop = 0;
+    while (!stop)
+    {
+        mosquitto_loop(mosq, -1, 1);
+        sem_getvalue(&mosquitto_stop, &stop);
+    }
+    tr_info("Mosquitto event loop stopped.");
+
+    void *result = NULL;
+    shutdown_and_cleanup();
+    int started;
+    sem_getvalue(&mqttpt_translator_started, &started);
+    if (started)
+    {
+        (void) pthread_join(mqttpt_thread, &result);
+    }
+    pt_client_free(client);
+    free(global_pt_ctx);
+    free(pt_cbs);
+
+    mosquitto_destroy(mosq);
+    mosquitto_lib_cleanup();
+
+    edge_trace_destroy();
+    return 0;
+}
+
+/**
+ * \brief The mqttpt client example shutdown handler.
+ *
+ * \param signum The signal number that initiated the shutdown handler.
+ */
+void shutdown_handler(int signum)
+{
+    sem_post(&mosquitto_stop);
+}
+
+/**
+ * \brief Set up the signal handler for catching signals from OS.
+ * This example signal handler setup catches SIGTERM and SIGINT for shutting down
+ * the protocol translator client gracefully.
+ */
+bool setup_signals(void)
+{
+    struct sigaction sa = { .sa_handler = shutdown_handler, };
+    struct sigaction sa_pipe = { .sa_handler = SIG_IGN, };
+    int ret_val;
+
+    if (sigemptyset(&sa.sa_mask) != 0)
+    {
+        return false;
+    }
+    if (sigaction(SIGTERM, &sa, NULL) != 0)
+    {
+        return false;
+    }
+    if (sigaction(SIGINT, &sa, NULL) != 0)
+    {
+        return false;
+    }
+    ret_val = sigaction(SIGPIPE, &sa_pipe, NULL);
+    if (ret_val != 0)
+    {
+        tr_warn("setup_signals: sigaction with SIGPIPE returned error=(%d) errno=(%d) strerror=(%s)",
+                ret_val,
+                errno,
+                strerror(errno));
+    }
+#ifdef DEBUG
+    tr_info("Setting support for SIGUSR2");
+    if (sigaction(SIGUSR2, &sa, NULL) != 0)
+    {
+        return false;
+    }
+#endif
+    return true;
+}
+
+/**
+ * @}
+ * close EDGE_PT_CLIENT_EXAMPLE Doxygen group definition
+ */
diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack_clip.h _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack_clip.h
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack_clip.h	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack_clip.h	2020-09-14 17:31:15.292260645 +0800
@@ -0,0 +1,352 @@
+/*
+ * ----------------------------------------------------------------------------
+ * Copyright 2018 ARM Ltd.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * ----------------------------------------------------------------------------
+ */
+
+#ifdef __cplusplus
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#endif
+
+
+typedef struct {
+    /* options without arguments */
+    int color_log;
+    int help;
+    /* options with arguments */
+    char *edge_domain_socket;
+    char *keep_alive;
+    char *mosquitto_host;
+    char *mosquitto_port;
+    char *app_id;
+    /* special */
+    const char *usage_pattern;
+    const char *help_message;
+} DocoptArgs;
+
+const char help_message[] =
+"MQTT Protocol Translator Example.\n"
+"\n"
+"Usage:\n"
+"  mqttpt-example [--edge-domain-socket <domain-socket>] [--mosquitto-port <int>] [--mosquitto-host <hostname>] [--keep-alive <int>] [--app-id <int>] [--color-log]\n"
+"  mqttpt-example --help\n"
+"\n"
+"Options:\n"
+"  -h --help                      Show this screen.\n"
+"  --edge-domain-socket <string>  Edge Core domain socket path [default: /tmp/edge.sock].\n"
+"  --mosquitto-port <int>         Mosquitto port number [default: 1883].\n"
+"  --mosquitto-host <string>      Mosquitto host address [default: 127.0.0.1].\n"
+"  --keep-alive <int>             Specify the keep-alive parameter in minutes [default: 60].\n"
+"  --app-id <int>                 Specify monitored application-id. MQTT topic: application/<app-id>/device/<device-eui>/<command> [default: 1].\n"
+"  --color-log                    Use ANSI colors in log.\n"
+"";
+
+const char usage_pattern[] =
+"Usage:\n"
+"  mqttpt-example [--edge-domain-socket <domain-socket>] [--mosquitto-port <int>] [--mosquitto-host <hostname>] [--keep-alive <int>] [--app-id <int>] [--color-log]\n"
+"  mqttpt-example --help";
+
+typedef struct {
+    const char *name;
+    bool value;
+} Command;
+
+typedef struct {
+    const char *name;
+    char *value;
+    char **array;
+} Argument;
+
+typedef struct {
+    const char *oshort;
+    const char *olong;
+    bool argcount;
+    bool value;
+    char *argument;
+} Option;
+
+typedef struct {
+    int n_commands;
+    int n_arguments;
+    int n_options;
+    Command *commands;
+    Argument *arguments;
+    Option *options;
+} Elements;
+
+
+/*
+ * Tokens object
+ */
+
+typedef struct Tokens {
+    int argc;
+    char **argv;
+    int i;
+    char *current;
+} Tokens;
+
+Tokens tokens_new(int argc, char **argv) {
+    Tokens ts = {argc, argv, 0, argv[0]};
+    return ts;
+}
+
+Tokens* tokens_move(Tokens *ts) {
+    if (ts->i < ts->argc) {
+        ts->current = ts->argv[++ts->i];
+    }
+    if (ts->i == ts->argc) {
+        ts->current = NULL;
+    }
+    return ts;
+}
+
+
+/*
+ * ARGV parsing functions
+ */
+
+int parse_doubledash(Tokens *ts, Elements *elements) {
+    //int n_commands = elements->n_commands;
+    //int n_arguments = elements->n_arguments;
+    //Command *commands = elements->commands;
+    //Argument *arguments = elements->arguments;
+
+    // not implemented yet
+    // return parsed + [Argument(None, v) for v in tokens]
+    return 0;
+}
+
+int parse_long(Tokens *ts, Elements *elements) {
+    int i;
+    int len_prefix;
+    int n_options = elements->n_options;
+    char *eq = strchr(ts->current, '=');
+    Option *option = NULL;
+    Option *options = elements->options;
+
+    len_prefix = (eq-(ts->current))/sizeof(char);
+    for (i=0; i < n_options; i++) {
+        option = &options[i];
+        if (!strncmp(ts->current, option->olong, len_prefix))
+            break;
+    }
+    if ((i == n_options) || (option == NULL)) {
+        // TODO '%s is not a unique prefix
+        fprintf(stderr, "%s is not recognized\n", ts->current);
+        return 1;
+    }
+    tokens_move(ts);
+    if (option->argcount) {
+        if (eq == NULL) {
+            if (ts->current == NULL) {
+                fprintf(stderr, "%s requires argument\n", option->olong);
+                return 1;
+            }
+            option->argument = ts->current;
+            tokens_move(ts);
+        } else {
+            option->argument = eq + 1;
+        }
+    } else {
+        if (eq != NULL) {
+            fprintf(stderr, "%s must not have an argument\n", option->olong);
+            return 1;
+        }
+        option->value = true;
+    }
+    return 0;
+}
+
+int parse_shorts(Tokens *ts, Elements *elements) {
+    char *raw;
+    int i;
+    int n_options = elements->n_options;
+    Option *option = NULL;
+    Option *options = elements->options;
+
+    raw = &ts->current[1];
+    tokens_move(ts);
+    while (raw[0] != '\0') {
+        for (i=0; i < n_options; i++) {
+            option = &options[i];
+            if (option->oshort != NULL && option->oshort[1] == raw[0])
+                break;
+        }
+        if ((i == n_options) || (option == NULL)) {
+            // TODO -%s is specified ambiguously %d times
+            fprintf(stderr, "-%c is not recognized\n", raw[0]);
+            return 1;
+        }
+        raw++;
+        if (!option->argcount) {
+            option->value = true;
+        } else {
+            if (raw[0] == '\0') {
+                if (ts->current == NULL) {
+                    fprintf(stderr, "%s requires argument\n", option->oshort);
+                    return 1;
+                }
+                raw = ts->current;
+                tokens_move(ts);
+            }
+            option->argument = raw;
+            break;
+        }
+    }
+    return 0;
+}
+
+int parse_argcmd(Tokens *ts, Elements *elements) {
+    int i;
+    int n_commands = elements->n_commands;
+    //int n_arguments = elements->n_arguments;
+    Command *command;
+    Command *commands = elements->commands;
+    //Argument *arguments = elements->arguments;
+
+    for (i=0; i < n_commands; i++) {
+        command = &commands[i];
+        if (!strcmp(command->name, ts->current)){
+            command->value = true;
+            tokens_move(ts);
+            return 0;
+        }
+    }
+    // not implemented yet, just skip for now
+    // parsed.append(Argument(None, tokens.move()))
+    /*fprintf(stderr, "! argument '%s' has been ignored\n", ts->current);
+    fprintf(stderr, "  '");
+    for (i=0; i<ts->argc ; i++)
+        fprintf(stderr, "%s ", ts->argv[i]);
+    fprintf(stderr, "'\n");*/
+    tokens_move(ts);
+    return 0;
+}
+
+int parse_args(Tokens *ts, Elements *elements) {
+    int ret;
+
+    while (ts->current != NULL) {
+        if (strcmp(ts->current, "--") == 0) {
+            ret = parse_doubledash(ts, elements);
+            if (!ret) break;
+        } else if (ts->current[0] == '-' && ts->current[1] == '-') {
+            ret = parse_long(ts, elements);
+        } else if (ts->current[0] == '-' && ts->current[1] != '\0') {
+            ret = parse_shorts(ts, elements);
+        } else
+            ret = parse_argcmd(ts, elements);
+        if (ret) return ret;
+    }
+    return 0;
+}
+
+int elems_to_args(Elements *elements, DocoptArgs *args, bool help,
+                  const char *version){
+    Command *command;
+    Argument *argument;
+    Option *option;
+    int i;
+
+    // fix gcc-related compiler warnings (unused)
+    (void)command;
+    (void)argument;
+
+    /* options */
+    for (i=0; i < elements->n_options; i++) {
+        option = &elements->options[i];
+        if (help && option->value && !strcmp(option->olong, "--help")) {
+            printf("%s", args->help_message);
+            return 1;
+        } else if (version && option->value &&
+                   !strcmp(option->olong, "--version")) {
+            printf("%s\n", version);
+            return 1;
+        } else if (!strcmp(option->olong, "--color-log")) {
+            args->color_log = option->value;
+        } else if (!strcmp(option->olong, "--help")) {
+            args->help = option->value;
+        } else if (!strcmp(option->olong, "--edge-domain-socket")) {
+            if (option->argument)
+                args->edge_domain_socket = option->argument;
+        } else if (!strcmp(option->olong, "--keep-alive")) {
+            if (option->argument)
+                args->keep_alive = option->argument;
+        } else if (!strcmp(option->olong, "--mosquitto-host")) {
+            if (option->argument)
+                args->mosquitto_host = option->argument;
+        } else if (!strcmp(option->olong, "--mosquitto-port")) {
+            if (option->argument)
+                args->mosquitto_port = option->argument;
+        } else if (!strcmp(option->olong, "--app-id")) {
+            if (option->argument)
+                args->app_id = option->argument;
+        }
+    }
+    /* commands */
+    for (i=0; i < elements->n_commands; i++) {
+        command = &elements->commands[i];
+    }
+    /* arguments */
+    for (i=0; i < elements->n_arguments; i++) {
+        argument = &elements->arguments[i];
+    }
+    return 0;
+}
+
+
+/*
+ * Main docopt function
+ */
+
+DocoptArgs docopt(int argc, char *argv[], bool help, const char *version) {
+    DocoptArgs args = {
+        0, 0, (char*) "/tmp/edge.sock", (char*) "60", (char*) "127.0.0.1",
+        (char*) "1883",(char*) "1",
+        usage_pattern, help_message
+    };
+    Tokens ts;
+    Command commands[] = {
+    };
+    Argument arguments[] = {
+    };
+    Option options[] = {
+        {NULL, "--color-log", 0, 0, NULL},
+        {"-h", "--help", 0, 0, NULL},
+        {NULL, "--edge-domain-socket", 1, 0, NULL},
+        {NULL, "--keep-alive", 1, 0, NULL},
+        {NULL, "--mosquitto-host", 1, 0, NULL},
+        {NULL, "--mosquitto-port", 1, 0, NULL},
+        {NULL, "--app-id", 1, 0, NULL}
+    };
+    Elements elements = {0, 0, 7, commands, arguments, options};
+
+    ts = tokens_new(argc, argv);
+    if (parse_args(&ts, &elements))
+        exit(EXIT_FAILURE);
+    if (elems_to_args(&elements, &args, help, version))
+        exit(EXIT_SUCCESS);
+    return args;
+}
diff -ruN mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack.docopt _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack.docopt
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/mqttpt-chirpstack/mqttpt_chirpstack.docopt	1970-01-01 08:00:00.000000000 +0800
+++ _mbed-edge-examples/mqttpt-chirpstack/mqttpt_chirpstack.docopt	2020-09-14 17:25:21.684423146 +0800
@@ -0,0 +1,14 @@
+MQTT Protocol Translator for ChirpStack-integration.
+
+Usage:
+  mqttpt-chirpstack [--edge-domain-socket <domain-socket>] [--mosquitto-port <int>] [--mosquitto-host <hostname>] [--keep-alive <int>] [--app-id <int>] [--color-log]
+  mqttpt-chirpstack --help
+
+Options:
+  -h --help                      Show this screen.
+  --edge-domain-socket <string>  Edge Core domain socket path [default: /tmp/edge.sock].
+  --mosquitto-port <int>         Mosquitto port number [default: 1883].
+  --mosquitto-host <string>      Mosquitto host address [default: 127.0.0.1].
+  --keep-alive <int>             Specify the keep-alive parameter in minutes [default: 60].
+  --app-id <int>                 Specify monitored application-id. MQTT topic: application/<app-id>/device/<device-eui>/<command> [default: 1].
+  --color-log                    Use ANSI colors in log.
\ No newline at end of file
--- mbed-edge-examples-cd505d1486a4a98800adb99c610706feabd60b11/CMakeLists.txt	2020-05-15 23:51:27.000000000 +0800
+++ _mbed-edge-examples/CMakeLists.txt	2020-09-14 17:16:13.608026731 +0800
@@ -55,6 +55,7 @@
 find_library(MOSQUITTO_LIB mosquitto)
 if (SKIP_LIB_CHECK OR MOSQUITTO_LIB)
   add_subdirectory (mqttpt-example)
+  add_subdirectory (mqttpt-chirpstack)
 else ()
   message("Not building the mqtt protocol translator since mosquitto library was not found!")
 endif ()
